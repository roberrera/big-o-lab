Insertion Sort:

func insertionSort( var a as array )
    for i from 1 to N
        for j from i to 1
            if a[j] < a[j-1]
                swap a[j] and a[j-1]
end func

// O(n^2) because there are two for loops nested.

Merge Sort:

func mergeSort( var a as array )
     if ( n == 1 ) return a

     var l1 as array = a[0] ... a[n/2]
     var l2 as array = a[n/2+1] ... a[n]

     l1 = mergesort( l1 )
     l2 = mergesort( l2 )
     // O(log)

     return merge( l1, l2 ) // O(n)
end func
// O(n) because, even though the method contains O(log) and a call to a method
//that is O(n), the slowest part of this method is the merge method, which is O(n).

func merge( var a as array, var b as array )
     var c as array

     while ( a and b have elements )
          if ( a[0] > b[0] )
               add b[0] to the end of c
               remove b[0] from b
          else
               add a[0] to the end of c
               remove a[0] from a
     while ( a has elements )
          add a[0] to the end of c
          remove a[0] from a
     while ( b has elements )
          add b[0] to the end of c
          remove b[0] from b
     return c
end func
// O(n) because each while loop checks the array n number of times, and they
// are not nested.

Selection Sort:

int i,j;

/* advance the position through the entire array */
/*   (could do j < n-1 because single element is also min element) */
for (j = 0; j < n-1; j++) {
    /* find the min element in the unsorted a[j .. n-1] */

    /* assume the min is the first element */
    int iMin = j;
    /* test against elements after j to find the smallest */
    for ( i = j+1; i < n; i++) {
        /* if this element is less, then it is the new minimum */
        if (a[i] < a[iMin]) {
            /* found new minimum; remember its index */
            iMin = i;
        }
    }

    if(iMin != j) {
        swap(a[j], a[iMin]);
    }
}
// O(n^2) because there is a for loop nested within the for loop.

Quick Sort:

func quicksort(var a as array, var low as int, var high as int){
    if (low < high)
        pivotLocation = partition(A,low,high)
        quicksort(a,low, pivot_location)
        quicksort(a, pivotLocation + 1, high)


func partition(var a as array, var low as int, var high as int){
    pivot = a[low]
    leftwall = low

    for i = low + 1 to high // O(n)
        if (a[i] < pivot)
            leftwall = leftwall + 1
            swap(a[i], a[leftwall])

    swap(a[low], a[leftwall])

    return (leftwall)
// O(n) because the quicksort method calls the partition method, which is O(n).
// Then it calls itself recursively twice.
